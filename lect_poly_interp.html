<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Numerical Methods</title>

		<meta name="description" content="Lecture Polynomial Interpolation and Approximation">
		<meta name="author" content="Tony Perkins">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1># Numerical Methods with Python</h1>
					<h3>Polynomial Interpolation and Approximation</h3>
					<p>
						<small>Created by <a href="http://toperkin.github.io/nm.html">Tony Perkins</a></small>
					</p>
				</section>

				<section>
					<h2>Connect the dots
					</h2>
					<p>
						<img src="http://toperkin.github.io/NumericalMethods/assets-lect_poly_interp/poly_interp.jpg" alt="" style="width: 500px;">

					</p>
				</section>

				<section>
					<h2>Polynomials
					</h2>
					<p> \[P_n(x) = a_nx^n+\cdots + a_1x+a_0\]
					</p>
				</section>

				<section>
<ul>
	<li>Commonly used for interpolation or approximation of functions</li>
	<li>Benefits include efficient methods, simple differentiation, and simple integration</li>
	<li>Weierstrass Approximation Theorem!</li>
</ul>
				</section>

				<section>
					<h2>Weierstrass Approximation Theorem:
					</h2>
					<p>For any $f\in C[a, b]$ and any $\varepsilon >0$, there is a polynomial $P(x)$ such that
						\[ |f(x)-P(x)|< \varepsilon \text{ for all } x \text{ in } [a, b]\]
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
						<img src="http://toperkin.github.io/NumericalMethods/assets-lect_poly_interp/poly_approx.png" alt="" style="width: 700px;">

					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p><b>Weierstrass Approximation Theorem</b> basically says that polynomials are good at approximating general functions.
					</p>
				</section>

				<section>
					<p>The proof of Weierstrass Approximation Theorem is a little to hard for us but you can find it here:</p>
					<p> Bartle, R. G., <i>The elements of real analysis</i>, pp. 165–172 </p>
				</section>

				<section>
					<h2>Lagrange Polynomial
					</h2>
					<p>If $x_0, \ldots, x_n$ are distinct and $f$ is given at the numbers a unique polynomial $P(x)$ of degree $\le n$ exists with
						\[f(x_n)=P(x_n) \text{ for } k=0, \ldots n\]
						The polynomial is
						\[P(x) = f(x_0)L_{n,0}(x) + \cdots + f(x_n)L_{n,n}(x) = \sum_{k=0}^nf(x_k)L_{n,k}(x)\]
						where
						\[L(n,k) = \prod_{i \neq k}\frac{(x-x_i)}{(x_k-x_i)}\]
					</p>
				</section>

				<section>
					<h2>Lagrange Polynomial Error Term
					</h2>
					<p>$x_0, \ldots, x_n$ distinct in $[a, b]$, $f\in C^{n+1}[a,b]$, then for $x\in [a, b]$ there exists $\zeta(x)$ in $(a,b)$ with
						\[f(x)=P(x)+\frac{f^{(n+1)}(\zeta(x))}{(n+1)!}(x-x_0)(x-x_1)\cdots(x-x_n)\]
						where $P(x)$ is the interpolating polynomial.
					</p>
				</section>

				<section>
					<p>The proof can be found <a href="http://toperkin.github.io/NumericalMethods/assets-lect_poly_interp/bf_112_3.pdf">here</a></p>
					<p>Burden and Faires pg112-113
					</p>
				</section>

				<section>
					<h2>Problem.
					</h2>
					<p>A practical difficulty with Lagrange interpolation is that the error term is difficult to apply, so the degree of the polynomial needed for the desired accuracy is generally not known until computations have been performed.
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>A common practice is to compute the results given from various polynomials until appropriate agreement is obtained. However, the work done in calculating the approximation by the second polynomial does not lessen the work needed to calculate the third approximation; nor is the fourth approximation easier to obtain once the third approximation is known, and so on.
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>We will now derive these approximating polynomials in a manner that uses the previous calculations to greater advantage.
					</p>
				</section>

				<section>
					<h2>Neville’s Method - the build up
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>Notation: $P_{m_1,m_2,\ldots,m_k}(x)$
					</h2>
					<p>Let $f$ be a function defined at $x_0, x_1, x_2,\ldots,x_n$, and suppose that $m_1, m_2, \ldots, m_k$ are $k$ distinct integers, with $0 \le m_i \le n$ for each $i$. The Lagrange polynomial that agrees with $f(x)$ at the $k$ points $x_{m_1}, x_{m_2}, \ldots , x_{m_k}$ is denoted $P_{m_1,m_2,\ldots,m_k}(x)$.
					</p>
				</section>

				<section>
					<h2>Example
					</h2>
					<p>Suppose that $x_0=1, x_1=2, x_2=3, x_3=4, x_4=6$, and $f(x)=e^x$. Determinethe interpolating polynomial denoted $P_{1,2,4}(x)$, and use this polynomial to approximate $f(5)$.
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p><b>Solution.</b> This is the Lagrange polynomial that agrees with $f (x)$ at $x_1 = 2, x_2 = 3$, and $x_4 = 6$. Hence</p><br />
						\[P_{1, 2, 4}(x) = \frac{(x-3)(x-6)}{(2-3)(2-6)}e^2 + \frac{(x-2)(x-6)}{(3-2)(3-6)}e^3\]<br />
						\[ + \frac{(x-2)(x-3)}{(6-2)(6-3)}e^6\]
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p><br />
					\[f(5)\approx P_{1, 2, 4}(5) = \frac{(5-3)(5-6)}{(2-3)(2-6)}e^2 + \frac{(5-2)(5-6)}{(3-2)(3-6)}e^3\]<br />
					\[ + \frac{(5-2)(5-3)}{(6-2)(6-3)}e^6\]<br />
					\[= -\frac{1}{2}e^2+e^3+\frac{1}{2}e^6\approx 218.105\]
				</section>

				<section>
					<h2>
					</h2>
					<p>Now we will describe a method for recursively generating Lagrange polynomial approximations.
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p><b>Theorem.</b> Let $f$ be defined at $x_0, x_1, \ldots, x_k$, and let $x_j$ and $x_i$ be two distinct numbers in this set. Then</p><br />
						\[P(x) = \frac{(x-x_j)P_{0,1,\ldots,j-1,j+1, \ldots, k}(x) - (x-x_i)P_{0,1,\ldots,i-1,i+1, \ldots, k}(x) }{(x_i-x_j)}\]<br />
						<p>is the $k^{\text{th}}$ Lagrange polynomial that interpolates $f$ at the $k+1$ points $x_0, x_1,\ldots, x_k$.</p>
				</section>

				<section>
					<h2>
					</h2>
					<p><i>proof (pt i).</i> Let</p><br />
						\[\hat{Q} \equiv P_{0,1,\ldots,j-1,j+1, \ldots, k} \text{ and } Q\equiv P_{0,1,\ldots,i-1,i+1, \ldots, k}.\]<br />
					<p>	Since $Q(x)$ and $\hat{Q}(x)$ are polynomials of degree $k-1$ or less, $P(x)$ is of degree at most $k$, where:
					</p><br />
					\[P(x) = \frac{(x-x_j)\hat{Q}(x) - (x-x_i)Q(x) }{(x_i-x_j)}\]<br />
				</section>

				<section>
					<h2>
					</h2>
					<p><i>proof (pt ii).</i> First note that $\hat{Q}(x_i)=f(x_i)$, implies that
					</p><br />
					\[P(x_i) =  \frac{(x_i-x_j)\hat{Q}(x_i) - (x_i-x_i)Q(x_i) }{(x_i-x_j)}\]<br />
					\[= \frac{(x_i-x_j)}{(x_i-x_j)}f(x_i) = f(x_i)\]
				</section>

				<section>
					<h2>
					</h2>
					<p><i>proof (pt iii).</i>  Similarly, since $Q(x_j)=f(x_j)$, we have $P(x_j)=f(x_j)$.
					</p>
					<p>In addition, if $0\le r\le k$, and $r$ is neither $i$ nor $j$, then $Q(x_r)=\hat{Q}(x_r)=f(x_r)$.  So</p><br />
					\[P(x_r) =  \frac{(x_r-x_j)\hat{Q}(x_r) - (x_r-x_i)Q(x_r) }{(x_i-x_j)}\]<br />
					\[= \frac{(x_i-x_j)}{(x_i-x_j)}f(x_r) = f(x_r)\]
				</section>

				<section>
					<h2>
					</h2>
					<p><i>proof (pt iv).</i> By definition, $P_{0,1,\ldots, k}(x)$ is the unique polynomial of degree at most $k$ that agrees with $f$ at $x_0, x_1, \ldots, x_k$.  Thus $P \equiv P_{0,1,\ldots, k}$. $\; \; \; \; \Box$
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>This theorem implies that the interpolating polynomials can be generated recursively.  The procedure that uses this result to recursively generate interpolating polynomial approximations is called <b>Neville’s method</b>.
					</p>
				</section>


				<section>
					<h2>
					</h2>
					<p>The $P$ notation used below is cumbersome because of the number of subscripts used to represent the entries.
					</p>
					<img src="http://toperkin.github.io/NumericalMethods/assets-lect_poly_interp/nev1.png" alt="" style="width: 700px;">
				</section>


				<section>
					<h2>
					</h2>
					<p>Note, however, that as an array is being constructed, only two subscripts are needed. Proceeding down the table corresponds to using consecutive points $x_i$ with larger $i$, and proceeding to the right corresponds to increasing the degree of the interpolating polynomial. Since the points appear consecutively in each entry, we need to describe only a starting point and the number of additional points used in constructing the approximation.
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>To avoid the multiple subscripts, we let $Q_{i,j}(x)$, for $0 \le j \le i$, denote the interpolating polynomial of degree $j$ on the $(j + 1)$ numbers $x_{i−j}, x_{i−j+1}, \ldots , x_{i−1}, x_i$; that is,
					</p>
					\[Q_{i,j} = P_{i-j, i-j+1, \ldots, i-1, i}.\]
				</section>

				<section>
					<h2>
					</h2>
					<p>Using this notation provides the $Q$ notation array below
					</p>
					<img src="http://toperkin.github.io/NumericalMethods/assets-lect_poly_interp/nev2.png" alt="" style="width: 900px;">
				</section>

				<section>
					<h2>Neville's Iterated Interpolation
					</h2>
					<p>
						To evaluate the interpolating polynomial $P$ on the $n + 1$ distinct numbers $x_0, \ldots , x_n$ at the number $x$ for the function $f$:
					</p>
				</section>

				<section>
					<h2>Input:
					</h2>
						<ul>
							<li>number $x$ we want to know $P$ at</li>
							<li>an array $x[i]$, the $x$ values of the points</li>
							<li>an array $y[i] = Q[i,0]$ the $y$ values of the points and first column of $Q$.</li>
					</ul>
				</section>

				<section>
					<h2>Output:
					</h2>
					<p>the table $Q$ with $P(x) = Q_{n,n}$
					</p>
				</section>


				<section>
					<p><b>sketch.</b>
					</p>
<pre><code>
for i in range(n):
    for j in range(i):
        Q[i,j](x) = ( (x-x[i-j])*Q[i, j-1](x) - (x-x[i])*Q[i-1,j-1])/(x[i]-x[i-j])
</code></pre>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>


				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

				<section>
					<h2>
					</h2>
					<p>
					</p>
				</section>

<section>
	<h2>
	</h2>
	<p>
	</p>
</section>


				<section>
					<h2>That's all folks (for now)!</h2>
					<p>These slides were prepared by <a href="http://toperkin.github.io/nm.html">Tony Perkins</a></p>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',


				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
